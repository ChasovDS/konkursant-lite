Путь до файла: D:\PetProjects\GIT_Library\SPB-SO\est-1\.env
Содержимое:
DATABASE_URL=sqlite+aiosqlite:///./test.db
SECRET_KEY=your_secret_key
JWT_ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30


----------------------------------------

Путь до файла: D:\PetProjects\GIT_Library\SPB-SO\est-1\alembic.ini
Содержимое:
# A generic, single database configuration.

[alembic]

script_location = alembic
prepend_sys_path = .
version_path_separator = os

# Указание на SQLite базу данных
sqlalchemy.url = sqlite+aiosqlite:///./test.db

[post_write_hooks]

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S


----------------------------------------

Путь до файла: D:\PetProjects\GIT_Library\SPB-SO\est-1\alembic\env.py
Содержимое:
import os
import sys
import asyncio
from logging.config import fileConfig
from sqlalchemy.ext.asyncio import AsyncEngine, create_async_engine
from sqlalchemy import pool, MetaData
from alembic import context

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from src.database import Base, metadata  # Использовать metadata
from src.auth.models import User
from src.projects.models import Project
from src.config import settings

config = context.config
fileConfig(config.config_file_name)

async_database_url = settings.database_url

target_metadata = metadata

def run_migrations_offline() -> None:
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"}
    )

    with context.begin_transaction():
        context.run_migrations()

async def run_migrations_online() -> None:
    connectable = create_async_engine(async_database_url, poolclass=pool.NullPool, connect_args={"check_same_thread": False})

    async with connectable.connect() as connection:
        await connection.run_sync(do_run_migrations)

def do_run_migrations(connection) -> None:
    context.configure(connection=connection, target_metadata=target_metadata, render_as_batch=True)

    with context.begin_transaction():
        context.run_migrations()

if context.is_offline_mode():
    run_migrations_offline()
else:
    asyncio.run(run_migrations_online())


----------------------------------------

Путь до файла: D:\PetProjects\GIT_Library\SPB-SO\est-1\src\config.py
Содержимое:
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    database_url: str
    secret_key: str
    jwt_algorithm: str
    access_token_expire_minutes: int

    class Config:
        env_file = ".env"

settings = Settings()


----------------------------------------

Путь до файла: D:\PetProjects\GIT_Library\SPB-SO\est-1\src\database.py
Содержимое:
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy import MetaData
from databases import Database
from .config import settings

DATABASE_URL = settings.database_url

database = Database(DATABASE_URL)

# Изменение подключения к созданию асинхронного двигателя
async_engine = create_async_engine(DATABASE_URL, future=True, echo=True, connect_args={"check_same_thread": False})

async_session = sessionmaker(bind=async_engine, expire_on_commit=False, class_=AsyncSession)

metadata = MetaData()
Base = declarative_base(metadata=metadata)


----------------------------------------

Путь до файла: D:\PetProjects\GIT_Library\SPB-SO\est-1\src\main.py
Содержимое:
from fastapi import FastAPI
from src.auth.router import auth_router
from src.projects.router import project_router
from src.database import database
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI()

# Подключение к маршрутам
app.include_router(auth_router, prefix="/auth")
app.include_router(project_router, prefix="/projects")

@app.on_event("startup")
async def startup():
    await database.connect()

@app.on_event("shutdown")
async def shutdown():
    await database.disconnect()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # URL вашего React фронт-энд приложения
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

----------------------------------------

Путь до файла: D:\PetProjects\GIT_Library\SPB-SO\est-1\src\auth\auth.py
Содержимое:
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from src.database import async_session
from src.auth import models, schemas, utils
from src.config import settings

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="auth/token")

async def get_db():
    async with async_session() as session:
        yield session

async def get_user(db: AsyncSession, user_id: int):
    result = await db.execute(select(models.User).filter(models.User.id_user == user_id))
    return result.scalars().first()

async def get_user_by_email(db: AsyncSession, email: str):
    result = await db.execute(select(models.User).filter(models.User.email == email))
    return result.scalars().first()

async def authenticate_user(db: AsyncSession, email: str, password: str):
    user = await get_user_by_email(db, email)
    if not user or not utils.verify_password(password, user.password_hash):
        return False
    return user

async def get_current_user(token: str = Depends(oauth2_scheme), db: AsyncSession = Depends(get_db)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.secret_key, algorithms=[settings.jwt_algorithm])
        email: str = payload.get("sub")
        if email is None:
            raise credentials_exception
        token_data = schemas.TokenData(email=email)
    except JWTError:
        raise credentials_exception
    user = await get_user_by_email(db, email=token_data.email)
    if user is None:
        raise credentials_exception
    return user


----------------------------------------

Путь до файла: D:\PetProjects\GIT_Library\SPB-SO\est-1\src\auth\models.py
Содержимое:
from sqlalchemy import Boolean, Column, String, Integer, Enum, DateTime, func
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
import enum
from src.database import Base, metadata  # Подключение metadata

# Определение модели User
class User(Base):
    __tablename__ = 'users'

    id_user = Column(Integer, primary_key=True, index=True)
    full_name = Column(String(100), nullable=False)
    email = Column(String(100), unique=True, nullable=False)
    password_hash = Column(String(255), nullable=False)
    role = Column(String(20), nullable=False, default='user')
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)

    # Добавление обратной связи
    projects = relationship("Project", back_populates="owner")


----------------------------------------

Путь до файла: D:\PetProjects\GIT_Library\SPB-SO\est-1\src\auth\router.py
Содержимое:
from fastapi import APIRouter, Depends, HTTPException, status, Response
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.ext.asyncio import AsyncSession
from datetime import timedelta
from src.auth import schemas, auth, utils, models
from src.config import settings

auth_router = APIRouter()

@auth_router.post("/token", response_model=schemas.Token)
async def login_for_access_token(
        form_data: OAuth2PasswordRequestForm = Depends(), db: AsyncSession = Depends(auth.get_db)):
    user = await auth.authenticate_user(db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=settings.access_token_expire_minutes)
    access_token = utils.create_access_token(data={"sub": user.email}, expires_delta=access_token_expires)
    return {"access_token": access_token, "token_type": "bearer"}

@auth_router.post("/register", response_model=schemas.User)
async def register_user(user_in: schemas.UserCreate, db: AsyncSession = Depends(auth.get_db)):
    user = await auth.get_user_by_email(db, email=user_in.email)
    if user:
        raise HTTPException(
            status_code=400,
            detail="Email already registered",
        )
    user_data = user_in.dict()
    user_data.pop("password")
    user_in_db = models.User(**user_data, password_hash=utils.get_password_hash(user_in.password))
    db.add(user_in_db)
    await db.commit()
    await db.refresh(user_in_db)
    return user_in_db

@auth_router.get("/users/me", response_model=schemas.User)
async def read_users_me(current_user: schemas.User = Depends(auth.get_current_user)):
    return current_user

@auth_router.post("/logout")
async def logout(response: Response):
    response.delete_cookie("session")
    return {"message": "Successfully logged out"}


----------------------------------------

Путь до файла: D:\PetProjects\GIT_Library\SPB-SO\est-1\src\auth\schemas.py
Содержимое:
from pydantic import BaseModel, EmailStr
from typing import Optional
from datetime import datetime
import enum

class UserRole(str, enum.Enum):
    user = "user"
    reviewer = "reviewer"

class UserBase(BaseModel):
    full_name: str
    email: EmailStr

class UserCreate(UserBase):
    password: str

class UserUpdate(UserBase):
    password: Optional[str] = None

class UserInDBBase(UserBase):
    id_user: int
    role: str
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True

class User(UserInDBBase):
    pass

class UserInDB(UserInDBBase):
    password_hash: str

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: str | None = None


----------------------------------------

Путь до файла: D:\PetProjects\GIT_Library\SPB-SO\est-1\src\auth\utils.py
Содержимое:
from passlib.context import CryptContext
from jose import jwt
from datetime import datetime, timedelta
from src.config import settings

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def create_access_token(data: dict, expires_delta: timedelta = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.access_token_expire_minutes)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.secret_key, algorithm=settings.jwt_algorithm)
    return encoded_jwt


----------------------------------------

Путь до файла: D:\PetProjects\GIT_Library\SPB-SO\est-1\src\projects\models.py
Содержимое:
from sqlalchemy import Column, String, Integer, Text, DateTime, func, ForeignKey
from sqlalchemy.orm import relationship
from src.database import Base

class Project(Base):
    __tablename__ = 'projects'

    id_project = Column(Integer, primary_key=True, index=True)
    title = Column(String, nullable=False)
    description = Column(Text)
    file_path = Column(String, nullable=False)
    owner_id = Column(Integer, ForeignKey('users.id_user'), nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)

    owner = relationship("User", back_populates="projects")


----------------------------------------

Путь до файла: D:\PetProjects\GIT_Library\SPB-SO\est-1\src\projects\router.py
Содержимое:

from fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File
from sqlalchemy.ext.asyncio import AsyncSession
from src.auth.auth import get_current_user
from src.auth.models import User
from src.projects.models import Project
from src.database import async_session
from src.projects import schemas


project_router = APIRouter()

async def get_db():
    async with async_session() as session:
        yield session

@project_router.post("/", response_model=schemas.Project)
async def create_project(
    project: schemas.ProjectCreate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    new_project = models.Project(**project.dict(), owner_id=current_user.id_user)
    db.add(new_project)
    await db.commit()
    await db.refresh(new_project)
    return new_project

@project_router.post("/uploadfile/")
async def upload_file(file: UploadFile = File(...)):
    file_location = f"files/{file.filename}"
    with open(file_location, "wb") as f:
        f.write(file.file.read())
    return {"file_path": file_location}


----------------------------------------

Путь до файла: D:\PetProjects\GIT_Library\SPB-SO\est-1\src\projects\schemas.py
Содержимое:
from pydantic import BaseModel
from typing import Optional
from datetime import datetime

class ProjectCreate(BaseModel):
    title: str
    description: Optional[str]
    file_path: str

class Project(BaseModel):
    id_project: int
    title: str
    description: Optional[str]
    file_path: str
    owner_id: int
    created_at: datetime
    updated_at: datetime

    class Config:
        orm_mode = True


----------------------------------------

